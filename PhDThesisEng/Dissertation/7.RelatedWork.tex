\chapter{Related Work}\label{ch:relatedWork}

% Раздел~\cref{sec:relatedWork/hornSolvers} данной главы посвящен сравнению предложенных методов решения систем дизъюнктов Хорна с алгебраическими типами данных и существующих методов, реализованных в таких инструментах, как \spacer{}, \racer{}, \eldarica{}, \vericat{}, \hoice{} и \rchc{}. Данные инструменты были отобраны по следующему принципу: инструменты, поддерживающие системы дизъюнктов Хорна над алгебраическими типами данных, которые проверяют как выполнимость, так и не выполнимость этих систем. Так, например, не рассматривались инструменты, решающие родственную проблему автоматизации индукции для теорем с алгебраическими типами данных, такие как, например, \cvc{} в режиме индукции~\cite{reynolds2015induction} (см. предыдущий раздел), \textsc{AdtInd}~\cite{10.1007/978-3-030-30048-7_35} и пр., поскольку они не принимают на вход системы дизъюнктов Хорна. Также не рассматривались инструменты логического программирование (такие, как \textsc{Prolog}~\cite{ClocksinMellish03}), поскольку они позволяют проверять только невыполнимость систем дизъюнктов Хорна и ничего не говорят об их выполнимости.
Section~\cref{sec:relatedWork/hornSolvers} of this chapter is dedicated to the comparison of proposed methods for solving Horn clause systems with algebraic data types and existing methods, implemented in tools such as \spacer{}, \racer{}, \eldarica{}, \vericat{}, \hoice{}, and \rchc{}. We selected only the tools supporting Horn clause systems over algebraic data types that verify both the satisfiability and unsatisfiability of these systems. For instance, tools addressing the related problem of automating induction for theorems with algebraic data types, such as, for example, \cvc{} in induction mode~\cite{reynolds2015induction} (see previous section), \textsc{AdtInd}~\cite{10.1007/978-3-030-30048-7_35} and others were not considered, as they do not accept Horn clause systems as input. Also, logic programming tools (such as \textsc{Prolog}~\cite{ClocksinMellish03}) were not considered because they only check the unsatisfiability of Horn clause systems and say nothing about their satisfiability.



% В разделе~\cref{sec:relatedWork/modelBuilding} представлен обзор альтернативных рассмотренным способов представления бесконечных множеств термов, основанных на обобщениях автоматов над деревьями, которые могут послужить в качестве классов индуктивных инвариантов программ в будущем.
Section~\cref{sec:relatedWork/modelBuilding} presents an overview of alternative ways of representing infinite sets of terms based on generalizations of tree automata that might serve as classes of inductive program invariants in the future.

\section{Horn Solvers with ADT Support}\label{sec:relatedWork/hornSolvers}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Comparison of Horn solvers with ADT support}\label{tab:hornSolvers}%
        \begin{tabular}{| m{41mm} || x{29mm} | x{28mm} | x{27mm} | x{26mm} |}
            \hline
            \hline
Tool & Invariant class & Method & Returns the invariant & Fully automatic\\\hline\hline
\spacer{} & \elemclass{} & \pdr{} & Yes & Yes\\
\racer{} & \catelemclass{} & \pdr{} & No & No\\
\eldarica{} & \sizeelemclass{} & \cegar{} & Yes & Yes\\
\vericat{} & -- & Transf. & No & Yes\\
\hoice{} & \elemclass{} & \ice{} & Yes & Yes\\
\rchc{}  & \syncRegFlatClass{} & \ice{} & Yes & Yes\\\hline
\ringenShort{\cvc} & \regclass{} & Transf. + \fmf{} & Yes & Yes\\
\ringenShort{\vampire} & -- & Transf. + Saturation & No & Yes\\
\ringenSyncShort{} & \syncRegFullClass{} & Transf. + \fmf{} & Yes & Yes\\
\ringenCICIShort{\cvc} & \regelemclass{} & \ourCEGAR{} & Yes & Yes\\
\ringenCICIShort{\vampire} & -- & \ourCEGAR{} & No & Yes\\
            \hline
            \hline
        \end{tabular}
    \end{threeparttable}
\end{table}

% В таблице~\cref{tab:hornSolvers} представлены результаты сравнения работе Хорн-решателей~--- существующих (верхний блок) и предложенных в данной (нижний блок). Предложенные Хорн-решатели описаны в предыдущей главе~\ref{ch:evaluation}, реализуемые ими методы описаны в главах~\ref{ch:fmf},~\ref{ch:SyncReg} и~\ref{ch:cici} данной работы. В таблице, для краткости, название \theringen{} сокращено до \theringenShort{}, так, например, Хорн-решатель \ringenSync{} в таблице представлен как \ringenSyncShort{}. Под словом <<Transf.>> имеется в виду, что инструмент построен на применении нетривиальных трансформаций к системе; аббревиатура <<FMF>> обозначает применение автоматического поиска конечных моделей (<<finite-model finding>>, см., например,~\cite{10.1007/978-3-319-40970-2_20,reynolds2013finite}); прочерк в столбце <<Класс инвариантов>> означает следующее: несмотря на то, что при выполнимости системы вывод инструмента неявно кодирует её индуктивный инвариант, не существует всюду останавливающейся процедуры, позволяющей этот вывод проверить. Остальные обозначения поясняются в подразделах, посвящённых соответствующим инструментам.
Table~\cref{tab:hornSolvers} presents the comparison of Horn solvers: existing ones (upper block) and those proposed in this work (lower block). The proposed Horn solvers are described in Chapter~\ref{ch:evaluation}, and the methods they implement are described in Chapters~\ref{ch:fmf},~~\ref{ch:SyncReg}, and~~\ref{ch:cici} of this work. In the table, for brevity, the name \theringen{} is abbreviated to \theringenShort{}, so for example, the Horn solver \ringenSync{} in the table is represented as \ringenSyncShort{}. The word ``Transf.'' indicates that the tool is built using non-trivial transformations of the system; ``FMF'' denotes the application of automatic finite-model finding (e.g., see~\cite{10.1007/978-3-319-40970-2_20,reynolds2013finite}); a dash in the ``Class of Invariants'' column means the following: although when the system is satisfiable, the output of the tool implicitly encodes its inductive invariant, there is no everywhere-halting procedure that allows this output to be checked. The other designations are explained in the subsections dedicated to the corresponding tools.

% Большинство рассмотренных инструментов отличаются классами, в которых они ищут индуктивные инварианты. Сравнение самих классов инвариантов было приведено в главе~\cref{ch:comparison}. В контексте сопоставления инструментов сравнение их классов инвариантов важно по следующей причине: если инструмент выводит инварианты в некотором классе, то проблема невыразительности этого класса (невозможность выразить определённые типы отношений) превращается в проблему незавершаемости этого инструмента. Иными словами, поскольку ни один из существующих инструментов не проверяет, существует ли \emph{вообще} инвариант для данной системы дизъюнктов Хорна в его классе\footnote{С одной стороны, эта задача по сложности сравнима с самой задачей верификации, с другой же стороны до сих пор ей были посвящены лишь отдельные работы (см., например,~\cite{10.1145/3022187,10.1145/2837614.2837640})}, то в случае отсутствия такового инструмент не будет завершаться.
Most of the tools examined differ in the classes in which they seek inductive invariants. A comparison of these classes of invariants was given in Chapter~\cref{ch:comparison}. This comparison is important for comparing tools for the following reason: if a tool outputs invariants in a certain class, then the problem of expressiveness of this class (the inability to express certain types of relations) becomes the problem of non-termination of this tool. In other words, since none of the existing tools check whether there is an invariant \emph{at all} for a given Horn clause system in its class\footnote{On the one hand, this task is as complex as the verification task itself; on the other hand, so far only a few studies have been dedicated to it (see, for example,~\cite{10.1145/3022187,10.1145/2837614.2837640})}, then in the absence of such, the tool will not terminate.

% Далее приведено краткое сравнительное описание существующих инструментов.
Further on, we provide a short comparartive descrition of the existing tools.

% \paragraph{Инструмент \spacer{}~\cite{komuravelli2016smt}} строит элементарные модели (класс \elemclass{} из раздела~\cref{sec:elem-def}). Этот инструмент создан на основе классической разрешающей процедуры для АТД, а также процедуры интерполяции и устранения кванторов~\cite{bjorner2015playing}. Ядром инструмента является подход \spacer{}, который основан на технике, называемой \emph{достижимость, направляемая свойством} \foreignlanguage{english}{(property-directed reachability, \pdr{})}, которая равномерно распределяет время анализа между поиском контрпримеров и построением безопасного индуктивного инварианта, распространяя информацию о достижимости небезопасных свойств и частичные леммы о безопасности. Инструмент позволяет выводить инварианты в комбинации алгебраических и других типов данных, возвращает проверяемые сертификаты. Подход, используемый в инструменте, корректен и полон. Недостатком инструмента является то, что он выражает инварианты в языке ограничений, а потому часто не завершается на проблемах с АТД.
\paragraph{The \spacer{} tool~\cite{komuravelli2016smt}} constructs elementary models (the \elemclass{} class). This tool is based on a classic satisfiability procedure for ADTs, as well as interpolation and quantifier elimination procedures~\cite{bjorner2015playing}. At its core, the tool employs the \spacer{} approach, which is based on a technique called \emph{property-directed reachability} (\pdr{}), evenly distributing analysis time between counterexample search and safe inductive invariant construction, propagating information about reachability of unsafe properties and partial safety lemmas. The tool allows for the output of invariants in a combination of algebraic and other data types, and returns verifiable certificates. The approach used in the tool is both sound and complete. A drawback of the tool is that it expresses invariants in the constraint language, and therefore often does not terminate on problems with ADTs.

% \paragraph{Инструмент \racer{}~\cite{10.1145/3498722}} является развитием инструмента \spacer{}, позволяя выводить инварианты в языке ограничений, расширенном катаморфизмами. Этот язык ограничений обозначен в таблице~\ref{tab:hornSolvers} как \catelemclass{}. \racer{} также наследует все достоинства подхода \spacer{}. Недостатком подхода является то, что он не полностью автоматический, поскольку требует вручную описывать катаморфизмы, что может быть затруднительно на практике, поскольку по заданной проблеме бывает сложно понять, какие катаморфизмы потребуются для её инварианта. Недостатком самого инструмента является то, что он не возвращает какие-либо проверяемые сертификаты с катаморфизмами.

\paragraph{The \racer{} tool~\cite{10.1145/3498722}} is an evolution of the \spacer{} tool, allowing for the output of invariants in the constraint language expanded with catamorphisms. This constraint language is denoted in table~\ref{tab:hornSolvers} as \catelemclass{}. \racer{} also inherits all the advantages of the \spacer{} approach. A drawback of the approach is that it's not fully automatic, as it requires manually describing catamorphisms, which can be challenging in practice because it can be difficult to understand which catamorphisms will be required for the invariant based on the given problem. A drawback of the tool itself is that it does not return any verifiable certificates with catamorphisms.

% \paragraph{Инструмент \eldarica{}~\cite{8603013}} строит модели с ограничениями размера термов, которые вычисляют общее количество вхождений конструкторов (\sizeelemclass{} из раздела~\cref{sec:sizeelem-def}). Это расширение весьма ограниченно увеличивает выразительность языка ограничений, поскольку введённая функция считает количество всех конструкторов одновременно, поэтому с её помощью невозможно выразить многие свойства, например, ограничение на высоту дерева. Инструмент \eldarica{} использует подход \cegar{} с абстракцией предикатов и встроенный SMT-решатель \princess{}~\cite{princess}, который предоставляет разрешающую процедуру, а также процедуру интерполяции для АТД с ограничениями на размер термов. Эти процедуры построены на сведении данной теории к комбинации теорий неинтерпретируемых функций и линейной арифметики~\cite{hojjat2017deciding}.
\paragraph{The \eldarica{} tool~\cite{8603013}} constructs models with term size constraints, which calculate the total number of constructor occurrences (the \sizeelemclass{} class). This extension only marginally enhances the expressiveness of the constraint language, as the introduced function counts all constructors at once, thus it cannot express many properties, such as a restriction on tree height. The \eldarica{} tool employs the \cegar{} approach with predicate abstraction and an embedded SMT solver \princess{}\cite{princess}, which provides a resolution procedure, as well as an interpolation procedure for algebraic data types with term size constraints. These procedures are built on the reduction of this theory to a combination of theories of uninterpreted functions and linear arithmetic\cite{hojjat2017deciding}.

% \paragraph{Инструмент \vericat{}~\cite{10.1093/logcom/exab090,pettorossi_proietti_2022,10.1007/978-3-030-51074-9_6,angelis_fioravanti_pettorossi_proietti_2018}} обрабатывает условия проверки над теориями линейной арифметики и АТД и полностью устраняет АТД из исходной системы дизъюнктов путём сворачивания (fold), разворачивания (unfold), введения новых дизъюнктов и других трансформаций. После работы инструмента получается система дизъюнктов Хорна без АТД, на которой может быть запущен любой эффективный Хорн-решатель, например, \spacer{} или \eldarica{}. Основным достоинством подхода является тот факт, что он рассчитан на работу с проблемами, где алгебраические типы данных комбинированы с другими теориями. Основные недостатки подхода заключаются в следующем: сам процесс трансформации может также не завершаться, кроме этого из-за трансформации невозможно восстановить инвариант исходной системы, т.\:е. инструмент не возвращает проверяемого сертификата.
\paragraph{The \vericat{} tool~\cite{10.1093/logcom/exab090,pettorossi_proietti_2022,10.1007/978-3-030-51074-9_6,angelis_fioravanti_pettorossi_proietti_2018}} processes verification conditions over theories of linear arithmetic and ADTs and completely eliminates ADTs from the original system of Horn clauses by folding, unfolding, introducing new clauses, and other transformations. It produces a Horn clause system without ADTs, on which any efficient Horn solver, such as \spacer{} or \eldarica{}, can be run. The main advantage of this approach is that it is designed to work with problems where algebraic data types are combined with other theories. The main drawbacks of the approach are as follows: the transformation process itself may also not terminate, and due to the transformation, it is impossible to recover the invariant of the original system, i.e., the tool does not return a verifiable certificate.

% \paragraph{Инструмент \hoice{}~\cite{10.1007/978-3-030-02768-1_8}} строит элементарные инварианты с помощью подхода, основанного на машинном обучении, \ice{}~\cite{10.1007/978-3-319-08867-9_5}. Его достоинством является возможность выводить инварианты в комбинации АТД с другими теориями, а также корректность и полнота, и, наконец, способность возвращать проверяемые сертификаты корректности. Его недостатком является то, что он выводит инварианты в невыразительном языке ограничений, а потому часто не завершается.
\paragraph{The \hoice{} tool~\cite{10.1007/978-3-030-02768-1_8}} constructs elementary invariants using an approach based on machine learning, \ice{}~\cite{10.1007/978-3-319-08867-9_5}. Its advantages include the ability to infer invariants for combinations of ADTs with other theories, as well as correctness and soundness, and finally, the ability to return verifiable correctness certificates. Its disadvantage is that it produces invariants in an expressive constraint language, and thus often does not terminate.

% \paragraph{Инструмент \rchc{}~\cite{haude2020,losekoot_et_al:LIPIcs.FSCD.2023.7},}также как и \hoice{}, использует подход \ice{}; \rchc{} основан на машинном обучении, однако выражает индуктивные инварианты программ над АТД при помощи \emph{автоматов над деревьями}~\cite{tata}. Но из-за сложностей с выражением кортежей термов автоматами, описанных в разделе~\ref{sec:comparison/undef-in-sync}, подход часто оказывается неприменим для простейших примеров, где существуют классические символьные инварианты. 
\paragraph{The \rchc{} tool~\cite{haude2020,losekoot_et_al:LIPIcs.FSCD.2023.7}} also uses the \ice{} approach; it is based on machine learning, but expresses inductive invariants of programs over ADTs using \emph{tree automata}~\cite{tata}. However, due to the complexities of expressing tuples of terms with automata, described in Section~\ref{sec:comparison/undef-in-sync}, the approach often proves inapplicable for even the simplest examples where classical symbolic invariants exist.

% \paragraph{Выводы.} Подводя итоги сравнения вышеозначенных инструментов и методов, можно сказать следующее. По сравнении с методом инструмента \rchc{} предложенные в данной диссертационной работе подходы являются альтернативными способами вывода регулярных инвариантов и их надклассов. Поэтому они могут быть совмещены с подходом инструмента \rchc{}, чтобы быстрее сходиться к индуктивному инварианту системы, если он существует. В сравнении с методами остальных существующих инструментов, предложенные подходы позволяют выводить инварианты в независимых классах регулярных инвариантов. Поэтому применение предложенных методов совместно с существующими позволит решать больше различных типов задач.
\paragraph{Conclusions.} Summarizing the comparison, the following can be said. Compared with the method of \rchc{}, the approaches proposed in this thesis provide alternative ways of inferring regular invariants and their superclasses. Therefore, they can be combined with the \rchc{} approach to converge faster to the inductive invariant of the system, if it exists. Compared with the methods of the remaining existing tools, the proposed approaches allow inferring invariants in independent classes of regular invariants. Therefore, the application of the proposed methods in conjunction with existing ones will solve a wider variety of problems.

% \section{Конечные представления множеств термов}\label{sec:relatedWork/modelBuilding}
\section{Finite Representations of Term Sets}\label{sec:relatedWork/modelBuilding}
% В данной работе были рассмотрены и предложены различные классы инвариантов для систем дизъюнктов Хорна над АТД, такие, как \elemclass{}, \regclass{}, \syncRegFlatClass{}, \syncRegFullClass{} и т.\:д. Ключевое требование к классам индуктивных инвариантов над АТД~--- это возможность представлять бесконечные множества кортежей термов конечным образом, чтобы с ними мог работать конечный вычислитель. Кроме этого, от них требуется замкнутость и разрешимость некоторых операций, которые были подробно рассмотрены в главе~\ref{ch:comparison}. Конечные представления множеств термов с такими свойствами исследуются в других областях информатики и могут быть использованы для вывода инвариантов.
In this work, various classes of invariants for Horn clause systems over ADTs, such as \elemclass{}, \regclass{}, \syncRegFlatClass{}, \syncRegFullClass{}, etc., were examined and proposed. A key requirement for classes of inductive invariants over ADTs is the ability to represent infinite sets of term tuples in a finite way so that a finite computer can work with them. Moreover, these representations need to provide closure and decidability of certain operations, which were discussed in detail in Chapter~\ref{ch:comparison}. Such finite representations of term sets are studied in other areas of computer science and can be used for invariant inference.

% Одной из альтернативных формулировок задачи конечного представления множеств термов является задача представления эрбрановских моделей, которой занимается область автоматического построения моделей (automated model building)~\cite{caferra2013automated}. Основная задача этой области~--- автоматически построить модель формулы логики первого порядка, когда её опровержение не может быть найдено. По теореме Эрбрана, формула выполнима тогда и только тогда, когда у неё есть эрбрановская модель, поэтому достаточно строить только эрбрановские модели, которые в общем случае содержат в себе бесконечные множества термов. Для автоматизации построения таких моделей рассматривают различные конечные их представления~\cite{fermuller2007model,fermuller2005model,teucke2019expressivity,gramlich2002algorithmic}. В частности, в этих работах приведены эффективные алгоритмы для работы с моделями, представленными автоматами над деревьями и их расширениями. Качественный обзор вычислительных представлений эрбрановских моделей, их свойств, выразительной силы и эффективности необходимых для работы с ними процедур представлен в работах~\cite{matzinger1998computational, matzinger2000computational}. Хотя предложенные в данных работах представления могут быть использованы для представления инвариантов над АТД, создание алгоритмов вывода таких инвариантов остаётся трудоёмкой задачей, которая не затрагивалась в этих работах.
An alternative formulation of the problem of finite term set representation is the task of Herbrand model representation, which is addressed in the field of automated model building~\cite{caferra2013automated}. The primary objective in this field is to automatically construct a model for a first-order logic formula when its refutation cannot be found. According to Herbrand's theorem, a formula is satisfiable if and only if it has a Herbrand model, thus it is sufficient to construct only Herbrand models, which generally contain infinite term sets. Various finite representations of such models are considered for the automation of model building~\cite{fermuller2007model,fermuller2005model,teucke2019expressivity,gramlich2002algorithmic}. In particular, these works provide efficient algorithms for working with models represented by tree automata and their extensions. A comprehensive review of computational representations of Herbrand models, their properties, expressiveness, and the efficiency of the procedures needed to work with them, is given in~\cite{matzinger1998computational, matzinger2000computational}. Although the representations proposed in these works can be used to represent invariants over ADTs, the development of algorithms for inferring such invariants remains a challenging task that has not been addressed in these studies.

% Задачу конечного представления множеств термов можно также сформулировать в контексте формальных языков деревьев как задачу построения расширений автоматов над деревьями, обладающих свойствами разрешимости и замкнутости базовых языковых операций, рассмотренных в главе~\ref{ch:comparison}. Языки деревьев систематически рассматриваются в контексте формальных языков~\cite{10.5555/267871}, в частности, существует множество работ, предлагающих внедрение различных видов синхронизации в автоматы над деревьями~\cite{chabin2007visibly, gouranton2001synchronized, limet2001weakly, chabin2006synchronized, jacquemard2009rigid, engelfriet2017multiple}. Однако с предлагаемыми в этой области представлениями есть несколько ограничений. С одной стороны, чаще всего предлагаются языки с эффективным (полиномиальным с низкой степенью полинома) алгоритмом парсинга (принадлежности кортежа термов языку), из-за чего предлагаемые языки имеют низкую выразительную силу. С другой стороны, часто предлагаются классы языков деревьев, не замкнутые относительно некоторых булевых операций, например, отрицания и пересечения, что делает задачу адаптации этих классов для вывода индуктивных инвариантов ещё более трудоёмкой.
The problem of finite term set representation can also be formulated in the context of tree formal languages as a task of constructing extensions of tree automata whose basic language operations are decidable and closed, as discussed in Chapter~\ref{ch:comparison}. Tree languages are systematically considered in the context of formal languages~\cite{10.5555/267871}, and in particular, there are numerous works proposing the integration of various types of synchronization into tree automata~\cite{chabin2007visibly, gouranton2001synchronized, limet2001weakly, chabin2006synchronized, jacquemard2009rigid, engelfriet2017multiple}. However, there are several limitations with the representations proposed in this area. On the one hand, languages with efficient (low-degree polynomial) parsing algorithms are often proposed, which consequently have low expressiveness due to the computational restrictions. On the other hand, often the proposed classes of tree languages are not closed under certain Boolean operations, such as negation and intersection, which makes the task of adapting these classes for inferring inductive invariants even more challenging.


% Стоит отдельно упомянуть работы по расширению автоматов над деревьями SMT-ограничениями из других теорий до т.\:н. символьных автоматов над деревьями~\cite{VEANES2015418,10.1145/2933575.2933578}. Класс инвариантов, построенный на таких автоматах, позволит проверять выполнимость систем дизъюнктов Хорна над комбинацией АТД с другими SMT-теориями, как было замечено в работе~\cite{10.1007/978-3-031-13188-2_13}. Авторы этой работы начали адаптацию символьных автоматов к задаче проверке выполнимости систем дизъюнктов Хорна в рамках, реализовав учитель для этого класса инвариантов в рамках подхода \ice{}. Дальнейшее исследование класса инвариантов, построенного на символьных автоматах над деревьями, в рамках задачи автоматического вывода инвариантов представляется наиболее перспективным.
The works that focus on extending tree automata with SMT constraints from other theories into symbolic tree automata deserve separate mention~\cite{VEANES2015418,10.1145/2933575.2933578}. The class of invariants built on such automata would enable checking the satisfiability of Horn clause systems over a combination of ADTs with other SMT theories, as noted in~\cite{10.1007/978-3-031-13188-2_13}. The authors of this work initiated the adaptation of symbolic automata to the task of satisfiability checking for Horn clause systems within the \ice{} framework, implementing a teacher for this class of invariants. Further exploration of the class of invariants built on symbolic tree automata in the context of automatic invariant inference seems particularly promising.

% Итак, конечные представления множеств кортежей термов, представленные в работах из этих областей, могут стать основой для будущих классов индуктивных инвариантов над АТД. Поскольку многие из них построены как расширения классов, рассмотренных в данной работе, предложенные в данной работе методы вывода инвариантов могут быть также адаптированы, чтобы выводить инварианты в новых классах.
Therefore, finite representations of tuple sets presented in works from these areas can serve as a foundation for future classes of inductive invariants over ADTs. Since many of them are constructed as extensions of the classes examined in this work, the methods of invariant inference proposed in this work can also be adapted to infer invariants in these new classes.