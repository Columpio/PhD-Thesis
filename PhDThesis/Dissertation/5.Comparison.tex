\chapter{Теоретическое сравнение классов индуктивных инвариантов}\label{ch:comparison}

В данной главе приведено теоретическое сопоставление существующих и предложенных классов индуктивных инвариантов для программ с алгебраическими типами данных.
Рассмотрены только те классы, известные из  литературы, для которых существуют полностью автоматические методы вывода инвариантов: элементарные инварианты (\elemclass{}, выводятся с помощью инструментов \spacer{}~\cite{komuravelli2016smt} и \hoice{}~\cite{10.1007/978-3-030-02768-1_8}), элементарные инварианты с ограничениями размера термов (\sizeelemclass{}, выводятся с помощью инструмента \eldarica{}~\cite{8603013}), регулярные инварианты (\regclass{}, выводятся с помощью инструмента \rchc{}~\cite{haude2020}, а также методом из главы~\cref{ch:fmf}), синхронные регулярные инварианты (\syncRegFlatClass{}, \syncRegFullClass{}, выводятся с помощью инструмента \rchc{}~\cite{haude2020}, а также методом из главы~\cref{ch:SyncReg}) и комбинированные инварианты (\regelemclass{}, выводятся методом из главы~\cref{ch:cici}).

Сопоставление выполнено на базе свойств, которые являются ключевыми для классов инвариантов: замкнутость относительно булевых операций,  разрешимость задачи принадлежности кортежа термов инварианту, разрешимость  проверки инварианта на пустоту (раздел~\cref{sec:comparison/boolean}), выразительная сила (раздел~\cref{sec:comparison/expressivity}).
Результаты теоретического сравнения приведены в таблицах~\cref{tab:boolClasses} и~\cref{tab:invClasses}.
В разделе~\ref{sec:relatedWork/modelBuilding} представлен обзор альтернативных рассмотренным способов представления бесконечных множеств термов, основанных на обобщениях автоматов над деревьями, которые могут послужить в качестве классов индуктивных инвариантов программ в будущем.


\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Теоретическое сравнение классов индуктивных инвариантов}\label{tab:boolClasses}%
        \begin{tabular}{| m{41mm} || c | c | c | c | c | c |}
            \hline
            \hline
            \diagbox[width=45mm]{Свойство}{Класс} & \elemclass{} & \sizeelemclass{} & \regclass{} & \syncRegFlatClass{} & \syncRegFullClass{} & \regelemclass{} \\
            \hline
            Замкнут по $\cap$       & Да & Да & Да\tnote{1} & Да\tnote{2} & Да\tnote{2} & Да \\
            Замкнут по $\cup$       & Да & Да & Да\tnote{1} & Да\tnote{2} & Да\tnote{2} & Да \\
            Замкнут по $\setminus$  & Да & Да & Да\tnote{1} & Да\tnote{2} & Да\tnote{2} & Да \\
            Разрешимо $\overline{t} \in I$          & Да\tnote{3} & Да\tnote{4} & Да\tnote{5} & Да\tnote{7} & Да\tnote{9} & Да\tnote{10} \\
            Разрешимо $I = \emptyset$    & Да\tnote{3} & Да\tnote{4} & Да\tnote{6} & Да\tnote{8} & Да\tnote{9} & Да\tnote{10}\\
            Выразимы рекурсивные отношения & Нет & Частично & Да & Да & Да & Да \\
            Выразимы синхронные отношения & Да & Да & Нет & Частично & Да & Да \\
            \hline
            \hline
        \end{tabular}
\setlength{\multicolsep}{0cm}
\begin{multicols}{2}
        \begin{tablenotes}
            \item [1] см.~\cite[свойство~3.2.9]{tata}
            \item [2] см.~раздел~\cref{sec:SyncReg/boolean}
            \item [3] см.~\cite{oppen1980reasoning}
            \item [4] см.~\cite{hojjat2017deciding}
            \item [5] см.~\cite[разд.~3.2.1 и теор.~1.7.2]{tata}
            \item [6] см.~\cite[разд.~3.2.1 и теор.~1.7.4]{tata}
            \item [7] см.~\cite[опр.~3.2.1 и теор.~1.7.2]{tata}
            \item [8] см.~\cite[опр.~3.2.1 и теор.~1.7.4]{tata}
            \item [9] см.~раздел~\cref{sec:SyncReg/decidability}
            \item [10] см.~\cite[следствие~2]{comon1994equational}
            \end{tablenotes}
\end{multicols}          
    \end{threeparttable}
\end{table}

\section{Замкнутость классов относительно булевых операций и разрешимость операций}\label{sec:comparison/boolean}

Свойства замкнутости и разрешимости для рассмотренных классов сведены в таблицу~\cref{tab:boolClasses}. Сноска в каждой ячейке таблица отсылает к соответствующей теореме; отсутствие сноски свидетельствует об очевидности утверждаемого в ячейке факта. Например, замкнутость классов \elemclass{}, \sizeelemclass{} и \regelemclass{} относительно булевых операций очевидна, т.\:к. они синтаксически строятся как языки первого порядка с соответствующими операциями.


\section{Сравнение выразительности классов инвариантов}\label{sec:comparison/expressivity}

\begin{table} [htbp]
\centering
\begin{threeparttable}% выравнивание подписи по границам таблицы
\caption{Теоретическое сравнение выразительности классов индуктивных инвариантов}\label{tab:invClasses}%
\begin{tabular}{| m{24mm} || x{25mm} | x{25mm} | x{15mm} | c | c | c |}
    \hline
    \hline
    Класс & \elemclass{} & \sizeelemclass{} & \regclass{} & \syncRegFlatClass{} & \syncRegFullClass{} & \regelemclass{} \\
    \hline
    \elemclass{} & $\emptyset$ & $\emptyset$ & \exLR{}\tnote{1,4,5} & \exLR{}\tnote{1,5} & \exLR{}\tnote{1} & $\emptyset$\\
    \sizeelemclass{} & $\infty$ & $\emptyset$ & \exLR{}\tnote{1,4,5} & \exLR{}\tnote{1,5} & \exLR{}\tnote{1} & \exLt{}\tnote{3} \\
    \regclass{} & \exEvenLeft{}\tnote{2} & \exEvenLeft{}\tnote{2} & $\emptyset$ & $\emptyset$\tnote{4} & $\emptyset$\tnote{4,5} & $\emptyset$\\
    \syncRegFlatClass{} & \exEvenLeft{}\tnote{2,7} & \exEvenLeft{}\tnote{2,4} & $\infty$\tnote{4} & $\emptyset$ & $\emptyset$\tnote{5} & \exLt{}\tnote{3}\\
    \syncRegFullClass{} & \exEvenLeft{}\tnote{2,4,5} & \exEvenLeft{}\tnote{2,4,5} & $\infty$\tnote{4,5} & $\infty$\tnote{5} & $\emptyset$ & \exLt{}\tnote{3,5}\\
    \regelemclass{} & $\infty$ & \exEvenLeft{}\tnote{2} & $\infty$ & \exLR{}\tnote{1,5} & \exLR{}\tnote{1} & $\emptyset$\\
    \hline
    \hline
\end{tabular}
\setlength{\multicolsep}{0cm}
\begin{multicols}{2}
\begin{tablenotes}
    \item [1] $\exLR{}\in\elemclass{} \setminus \syncRegFullClass{}$ (лемма~\ref{lemm:lr-not-in-reg-full})
    \item [2] $\exEvenLeft{} \in \regclass{} \setminus \sizeelemclass{}$ (теор.~\ref{thm:exEvenLeft})
    \item [3] см. теор.~\ref{thm:exLt}
    \item [4] $\regclass{}\subseteq\syncRegFlatClass{}$~\cite[свойство~3.2.6]{tata}
    \item [5] $\syncRegFlatClass{}\subseteq\syncRegFullClass{}$~\cite[теор.~11]{haude2020}
\end{tablenotes}
\end{multicols}
\end{threeparttable}
\end{table}

\invariantreprclasses{\label{fig:Representations-new}}

Результаты сравнения выразительности классов инвариантов представлены в таблице~\ref{tab:invClasses}.
Поскольку некоторые классы построены как синтаксические расширения других классов (например, \syncRegFlatClass{} и \syncRegFullClass{} как расширяют \regclass{}), а некоторые классы синтаксически различаются очень сильно (например, \regclass{} и \elemclass{}), взаимосвязи между представляемыми ими множествами не очевидны.
Разграничить классы инвариантов важно для проведения анализа алгоритмов вывода инвариантов, в частности, для понимания границ их применимости. Если инварианты проблем какого-то вида не лежат в классе инвариантов, выводимых данным алгоритмом, то этот алгоритм не будет завершаться на проблемах данного вида.
Поэтому эти взаимосвязи важны и представлены в таблице~\ref{tab:invClasses}.

Для класса $A$ в строке и класса $B$ в столбце в соответствующей им ячейке находится сноска, а также либо символ $\emptyset$, либо $\infty$, либо название некоторой системы дизъюнктов из данной работы.
Каждую ячейку следует читать как ответ на вопрос: <<Что находится в классе $A\setminus B$?>> Если в ячейке находится $\emptyset$, значит $A\setminus B = \emptyset$. Если в ячейке находится $\infty$, значит $B \subseteq A$. Наконец, если в ячейке находится название системы $\prog$, значит, классы $A$ и $B$ несравнимы, т.\:е. $\prog \in A \setminus B \neq \emptyset$ и при этом $B \setminus A \neq \emptyset$.
Сноска отсылает к соответствующей теореме, представленной в данной  работе. Отсутствие сноски означает очевидность приводимого факта.
Например, в ячейке $\sizeelemclass{}\setminus\elemclass{}$ находится $\infty$ без сноски, т.\:к. класс $\sizeelemclass{}$ является синтаксическим расширением класса $\elemclass{}$, следовательно, включает, как минимум, те же инварианты.

На рисунке~\cref{fig:Representations-new} для удобства отдельно представлены связи включения между классами инвариантов. Ребро, ведущее из класса $A$ в класс $B$ с меткой $\prog$ означает, что $A\subsetneq B$ и $\prog\in B \setminus A$.


\subsection{Невыразимость в синхронных языках}\label{sec:comparison/undef-in-sync}

\begin{example}[\exNode{}]\label{ex:node}
    Рассмотрим следующее множество термов над алгебраическим типом бинарных деревьев $Tree ::= left\,|\,node(Tree, Tree)$:
    $$ \exNode{} \eqdef \big\{ \tuple{Node(y, z), y, z} \mid y, z\in\groundTerms{} \big\}. $$
\end{example}

Этот пример позволяет разделить классы синхронных регулярных инвариантов с полной и стандартной свёртками, как показывает следующая лемма.

\begin{lemma}\label{lemm:node-not-in-reg-flat}
    
Существуют синхронные регулярные инварианты с полной свёрткой, которые невыразимы при помощи только стандартной свёртки, т.\:е. $\exNode{}\in\syncRegFullClass{}\setminus\syncRegFlatClass{}$.
\end{lemma}
\begin{proof}
    Факт $\exNode{}\in\syncRegFullClass{}$ следует из применения теоремы~\ref{theorem:anyPatternClosure} к языку равенства двух термов и линейному шаблону $\tuple{Node(y, z), y, z}$.
    Справедливость $\exNode{}\not\in\syncRegFlatClass{}$ показана в~\cite[упр.~3.2]{tata} применением леммы о <<накачке>> для языков автоматов над деревьями к языку $\exNode{}$.
\end{proof}

\begin{example}[\exLR{}]\label{ex:lr}
    Рассмотрим следующее множество термов над алгебраическим типом бинарных деревьев $Tree ::= left\,|\,node(Tree, Tree)$:
    $$ \exLR{} \eqdef \big\{ x \mid \exists t\ .\ x = node(t, t) \big\}. $$
\end{example}

Это множество лежит в классе элементарных инвариантов, однако не может быть выражено никаким синхронным автоматов над деревьями даже с полной синхронизацией, как показывает следующая лемма.

\begin{lemma}\label{lemm:lr-not-in-reg-full}
Существуют элементарные инварианты, которые не являются инвариантами, выразимыми регулярно с полной синхронизацией, т.\:е. 
    $\exLR{}\not\in\syncRegFullClass{}$.
\end{lemma}
\begin{proof}
    В~\cite[упр.~1.4]{tata} применением леммы о <<накачке>> к языку $\exLR{}$ показано, что $\exLR{}\not\in\regclass{}$. По лемме~\ref{lemma:reg-full-one-is-reg}, из этого следует $\exLR{}\not\in\syncRegFullClass{}$.
\end{proof}

\subsection{Невыразимость в комбинированных языках}
\begin{theorem}\label{thm:exLt}
  Пересечение классов \sizeelemclass{} и \syncRegFlatClass{} не лежит в классе \regelemclass{}, т.\:е. $\exLt{} \in \sizeelemclass{}$, $\exLt{}\in\syncRegFlatClass{}$, $\exLt{}\not\in\regelemclass{}$
\end{theorem}
\begin{proof}
    Множество $\exLt{}$ выражается следующей \sizeelemclass{}-формулой:  $$\phi(x, y) \eqdef \sizename(x) < \sizename(y).$$

    Истинность утверждения $\exLt{}\in\syncRegFlatClass{}$ была доказана в примере~\ref{ex:lt}.

    Покажем теперь, что $\exLt{}$ не лежит в классе $\regelemclass{}$. Заметим, что алгебраический тип целых чисел Пеано изоморфмен натуральным числам (с нулём). Кроме того, формулы, представляющие множества из класса $\regelemclass{}$, изоморфны формулам в сигнатуре расширенной арифметики Пресбургера без сложения и порядка. Рассмотрим эту сигнатуру $\signature = \tuple{\sorts, \fsymbs, \psymbs}$, включающую единственный сорт натуральных чисел ($\sorts = \{\mathbb{N}\}$), константа $0$ и единственный функциональный символ следования~$s$ ($s(x)$ интерпретируется как $x + 1$, $\fsymbs=\{0, s\}$), а также предикатные символы равенства и делимости на все константы ($c \mid x$ интерпретируется как $x$ делится на $c$, $\psymbs=\{=\}\cup\{c \mid \_ , c \in \mathbb{N}\}$). Поскольку множество $lt$ представляет отношение строгого порядка, для доказательства исходного утверждения необходимо показать, что стандартное отношение порядка на натуральных числах невыразимо в теории стандартной модели $\mathcal{N}$ сигнатуры~$\signature$.

    Докажем это утверждение, расширив доказательство~\cite[разд.~2]{kossak2023undefinability} для арифметики с аналогичной сигнатурой без предикатов делимости.
    Рассмотрим модель $\mathcal{M} = (\mathbb{N}\cup\mathbb{N}^*, s, c\mid\_)$, где множество $\mathbb{N}^*$ определено как множество символов $\{n^* \mid n \in\mathbb{N}\}$; $c \mid n$ и $c \mid n^*$ выполняются только когда $c$ делит $n$; функция следования определена следующим образом:
    \begin{align*}
        s(n) &\eqdef n + 1\\
        s(n^*) &\eqdef (n + 1)^*
    \end{align*}
    
    Модель $\mathcal{M}$ является элементарным расширением модели $\mathcal{N}$, поэтому если некоторая формула $\psi(x, y)$ определяет линейный порядок на $\mathcal{N}$, она определяет линейный порядок и на~$\mathcal{M}$. Заметим, что следующее отображение $\sigma$ является автоморфизмом модели~$\mathcal{M}$:
    \begin{align*}
        \sigma(n) &\eqdef n^*\\
        \sigma(n^*) &\eqdef n
    \end{align*}
    
    Из того факта, что $\sigma$~--- автоморфизм модели $\mathcal{M}$, следует, что для любых $x, y \in \mathbb{N}\cup\mathbb{N}^*$ верно, что $\mathcal{M}\models \psi(x, y) \Leftrightarrow \mathcal{M}\models \psi(\sigma(x), \sigma(y))$. Поскольку формула $\psi$ по предположению выражает линейный порядок, без ограничений общности допустим, что $\mathcal{M}\models \psi(0, 0^*)$, но тогда, применив автоморфизм $\sigma$, получим, что $\mathcal{M}\models \psi(0^*, 0)$, что противоречит аксиомам порядка. Следовательно, никакая формула данной сигнатуры не может представлять линейный порядок. Из этого следует, что $\exLt{}$ не лежит в классе $\regelemclass{}$.
\end{proof}




\subsection{Невыразимость в элементарных языках}
В данном разделе представлены леммы о <<накачке>> для языков первого порядка~--- языка ограничений и языка ограничений, расширенного ограничениями на размер термов.

Первые леммы о <<накачке>> возникли в теории формальных языков~\cite{BARHILLELPERLESSHAMIR} в связи с конечными автоматами и контекстно-свободными грамматиками.
В общем виде любая лемма о <<накачке>> должна показывать, что для всех языков в некотором классе (например, регулярных или контекстно-свободных языков) любое достаточно большое слово может быть <<накачано>>. Иными словами, некоторые части слова могут быть неограниченно увеличены, и <<накачанное>> слово при этом останется в языке. Леммы о <<накачке>> полезны для доказательства невыразимости инварианта в некотором классе: предположив, что инвариант принадлежит классу, можно применить специализированную лемму о <<накачке>> для этого класса и получить некоторое <<накачанное>> множество. Если оно не может быть индуктивным инвариантом, то получено противоречие, следовательно, инвариант невыразим в данном классе.

Для формулировки лемм о <<накачке>> в начале определим следующее расширение языка ограничений, обозначаемое $\elemextclass{}$, которое допускает устранение кванторов.
Для каждого АТД $ \tuple{\sigma, C} $ и каждого конструктора $ f \in C $, имеющего арность $ \sigma_1 \times \dots \times \sigma_n \rightarrow \sigma $ для некоторых сортов $ \sigma_1, \ldots, \sigma_n $, введём \emph{селекторы} $ g_i \in S $ с арностью $ \sigma \rightarrow \sigma_i $ для каждого $ i \leq n $ со стандартной семантикой, заданной так: $ g_i (f (t_1, \ldots, t_n)) \eqdef t_i $.

\begin{theorem}[см.~\cite{oppen1980reasoning}]
    Всякая $\elemclass{}$-формула эквивалентна некоторой бескванторной $\elemextclass{}$-формуле.
\end{theorem}

Дадим несколько вспомогательных определений.

\begin{define}
Высоту замкнутого терма определим  индуктивно следующим образом:
\begin{align*}
    \height{c} & \eqdef 1\\
    \height{c (t_1, \ldots, t_n)} & \eqdef 1 + \max_{i = 1} ^ n \big (\height{t_i} \big).
\end{align*}
\end{define}

Будем называть \emph{путём} (возможно пустую) последовательность селекторов $ s \eqdef S_1 \ldots S_n $, где для каждого $i$ от $1$ до $n$, $S_i$ имеет сорт $\sigma_i \rightarrow \sigma_{i-1}$. Для терма $ t $ сорта $ \sigma_n $ пусть $ \subterm{t}{s} \eqdef S_1 (\ldots (S_n (t)) \ldots) $.
Для замкнутого терма $ g $ переопределим $ \subterm{g}{s} $ как вычисленный подтерм $ g $ в $ s $.
В дальнейшем будем обозначать пути прописными буквами $ p, q, r, s $.

Мы говорим, что два пути $ p $ и $ q $ \emph{перекрываются}, если один из них является суффиксом другого.
Для попарно неперекрывающихся путей $ p_1, \ldots, p_n $ с помощью записи  $ t [p_1 \leftarrow u_1, \ldots, p_n \leftarrow u_n] $ обозначим терм, полученный одновременной заменой  в $ t $ подтермов $ \subterm{t}{p_i} $ на термы $ u_i $. Для конечной последовательности попарно различных путей $ P = (p_1, \ldots, p_n) $ и некоторого множества термов $ U = (u_1, \ldots, u_n) $ мы переопределяем обозначения и пишем $ t [P \leftarrow U] $ вместо $ t [p_1 \leftarrow u_1, \ldots, p_n \leftarrow u_n] $, а также $ t [P \leftarrow t] $ вместо $ t [p_1 \leftarrow t, \ldots, p_n \leftarrow t ] $.

Теперь определим множество путей, которое будет <<накачиваться>>.
\begin{define}
Терм $ t $ является \emph{листовым термом} сорта $ \sigma $,
если это конструктор без параметров,
или $ t = c (t_1, \ldots, t_n) $, где все $ t_i $ являются листовыми термами, а $ t $ не содержит никаких собственных подтермов сорта $ \sigma $. Для замкнутого терма $ g $ и сорта $ \sigma $ определим $ \leafpos{\sigma}{g} \eqdef \{p \mid \subterm{g}{p} \text{~--- листовой терм сорта } \sigma \} $.
\end{define}

\defPumpLemmaElem{}
\begin{proof}
Доказательство приведено в работе~\cite{10.1145/3453483.3454055}.
\end{proof}

Фактически, лемма~\ref{lemm:pump-elem} утверждает, что для достаточно больших кортежей термов можно взять любой из самых глубоких подтермов, заменить его на \emph{произвольный} терм $ t $ и \emph{всё ещё} получить кортеж термов из данного языка.
Данная лемма формализует тот факт, что язык ограничений над теорией АТД может описывать только равенства и неравенства между подтермами ограниченной глубины: если пойти достаточно глубоко и заменить листовые термы произвольными термами, то начальный и результирующий термы будут \emph{неотличимы} формулой языка первого порядка.

\begin{theorem}
Существуют регулярные, но неэлементарные инварианты, т.\:е. $\regclass{} \setminus \elemclass{} \neq \emptyset$.
\end{theorem}
\begin{proof}
    Рассмотрим  систему дизъюнктов Хорна над алгебраическим типом целых чисел Пеано  \natDef{}, которая проверяет чётность чисел и утверждает, что никакие два соседних числа не могут быть чётными:
    \begin{align*}
        x = Z &\rightarrow ev(x)\\
        ev(y) \land x = S(S(y)) &\rightarrow ev(x)\\
        ev(x) \land ev(y) \land x = S(y) &\rightarrow \bot
    \end{align*}

    Система из этого примера имеет единственный индуктивный инвариант~--- множество $ E = \{ S^n(Z) \mid n \geq 0 \} $. Это можно доказать от противного: если расширить это множество некоторым нечетным числом $ E \cup \{S ^{2n + 1} (Z) \} \subseteq E '$, то будет нарушено условие запроса при $ x = S ^{2n} (Z) $ и $ y = S ^{2n + 1} (Z) $.
    Таким образом, множество $E$ оказывается единственным безопасным индуктивным инвариантом этой системы.

    Легко видеть, что множество $E$ выразимо следующим автоматом над деревьями (и следовательно, система имеет индуктивный инвариант в классе \regclass{}):
    \exampleTwo{}

    Докажем, что множество $E$ невыразимо формулой языка ограничений.
    Предположим, что множество $E$ элементарно. Возьмём постоянную $ K> 0 $ из леммы~\ref{lemm:pump-elem}. Пусть $ g \equiv S ^{2K} (Z) \in E, \sigma = Nat, p = S ^{2K} $. Далее, $ \bigcup_j \leafpos{\sigma}{g_j} = \leafpos{\sigma}{g} = \{p \} $, поэтому $ P = \{p \} $. Тогда по лемме~\ref{lemm:pump-elem} найдётся такое $ N \geq 0 $, что если взять $ t \equiv S ^{2N + 1} (Z) $, то $ g [P \leftarrow t] \equiv S ^{2K} (S ^{2N + 1} (Z)) \in E $. Следовательно, множеству $E$ принадлежит нечётное число, что противоречит определению этого множества чётных чисел.
\end{proof}

Сформулируем аналогичную лемму для языка первого порядка с ограничениями на размер терма. Для этого рассмотрим соответствующее расширение селекторами \sizeelemextclass{}, которое допускает устранение кванторов.

\begin{theorem}[см.~\cite{zhang2004decision}]
    Всякая $\sizeelemclass{}$-формула эквивалентна некоторой бескванторной $\sizeelemextclass{}$-формуле.
\end{theorem}

\begin{define}
Заимствуя обозначения из работы~\cite{hojjat2017deciding}, положим $ \termsOfSize{\sigma}{k} = \{t \text{ имеет сорт } \sigma \mid \sizename(t) = k \} $.
Для каждого  $ \sigma $, являющегося АТД-сортом,  определим множество размеров термов $ \sizesOfSort{\sigma} = \{\sizename(t) \mid t \in \huniv{\sigma} \} $.
\emph{Линейное множество}~--- это множество вида $ \{\mathbf{v} + \sum_{i = 1} ^ n k_i \mathbf{v_i} \mid k_i \in \mathbb{N} _0 \}$, где все $\mathbf{v}$  и $\mathbf{v_i}$ являются  векторами над $ \mathbb{N} _0 = \mathbb{N} \cup \{0 \} $.
\end{define}

\begin{define}
АТД-сорт $ \sigma $ называется \emph{расширяющимся}, если для каждого натурального числа $ n $ существует граница $ b (\sigma, n) \geq 0 $ такая, что для каждого $ b '\geq b (\sigma , n) $, если $ \termsOfSize{\sigma}{b '} \neq \emptyset $, то $ \sizeofSet{\termsOfSize{\sigma}{b'}} \geq n $.
Сигнатура АТД называется расширяющейся, если все её сорта расширяющиеся.
\end{define}

\defPumpLemmaSizeElem{}
\begin{proof}
Доказательство приведено в работе~\cite{10.1145/3453483.3454055}.
\end{proof}

Основная идея леммы~\ref{lemm:pump-sizeelem} заключается в том, что имея язык из класса \sizeelemclass{}, достаточно большой терм $ g $ из него и достаточно большой путь $ p $, можно заменить $ \subterm{g}{p} $ произвольным термом $ t $ (его размер должен находиться в некотором линейном бесконечном множестве $ T $), и вновь получить терм из этого языка. Данный факт, в свою очередь, означает, что в каждом бесконечном языке из класса \sizeelemclass{} существуют подтермы, которые неотличимы его формулами.

\begin{example}[\exEvenLeft{}]\label{ex:even}
    Рассмотрим систему дизъюнктов Хорна над алгебраическим типом бинарных деревьев $Tree ::= left\,|\,node(Tree, Tree)$, которая проверяет, является ли  количество узлов в самой левой ветви дерева чётным.
\begin{align*}
    x = leaf & \rightarrow even(x) \\
     x = node (node (x ', y), z) \land even(x') & \rightarrow even(x) \\
     even(x) \land even(node (x, y)) & \rightarrow \bot
\end{align*}

    Как показано ниже, у этой системы не существует инварианта, выразимого элементарно даже с ограничениями на размер термов.
\end{example}

\begin{theorem}\label{thm:exEvenLeft}
Существуют регулярные инварианты, которые не являются инвариантами, выразимыми элементарно с ограничениями на размер термов, т.\:е. $\exEvenLeft{} \in \regclass{} \setminus \sizeelemclass{}$.
\end{theorem}
\begin{proof}
    Инвариант системы \exEvenLeft{} выражает автомат $\Automaton{s_0, s_1}{s_0}$ с правилами перехода $ \autTrans $, описываемыми следующим образом:
\begin{align*}
leaf & \mapsto s_0 \\
node (s_0, s_0) & \mapsto s_1 \\
node (s_0, s_1) & \mapsto s_1 \\
node (s_1, s_0) & \mapsto s_0 \\
node (s_1, s_1) & \mapsto s_0
\end{align*}

Используя лемму о <<накачке>>, можно доказать, что инвариант \exEvenLeft{} не лежит в классе \sizeelemclass{}.
Во-первых, очевидно, что сорт $ \mathit{Tree} $ является расширяющимся. Предположим, что \exEvenLeft{} находится в классе \sizeelemclass{} и имеет инвариант $ \formallang{} $.
Возьмём $ K> 0 $ из леммы~\ref{lemm:pump-sizeelem}. Пусть $ g \in \formallang{} $ будет полным двоичным деревом высоты $ 2K $, $ \sigma = \mathit{Tree}, p = \mathit{Left} ^{2K} $.
Возьмём бесконечное линейное множество $ T $ из леммы.
Мы можем найти некоторое $ n \in T, n> 2 $ и $ t = node (leaf, t ') $ для некоторого $ t' $ такие, что $ \sizename{} (t) = n $.
По лемме~\ref{lemm:pump-sizeelem} существует последовательность путей $ P $ и последовательность термов $ U $, и ни один из элементов в $ P $ не является суффиксом $ p $;
    также должно быть верно, что $ g [p \leftarrow t, P \leftarrow U] \in \formallang{} $, поэтому крайний левый путь в дереве должен иметь чётную длину. Однако по крайнему левому пути $ p = \mathit{Left} ^{2K} $ лежит терм $ node (leaf, t ') $, поэтому путь до крайнего левого листа дерева имеет длину $ 2K - 1 + 2 = 2К + 1 $, являясь нечётным числом. Итак, имеем противоречие с тем, что путь до крайнего левого листа в каждом терме множества \exEvenLeft{} имеет чётную длину, следовательно \exEvenLeft{} не лежит в классе \sizeelemclass{}.
\end{proof}

\section{Конечные представления множеств термов}\label{sec:relatedWork/modelBuilding}

В данной диссертационной работе были рассмотрены и предложены различные классы инвариантов для систем дизъюнктов Хорна над АТД, такие, как \elemclass{}, \regclass{}, \syncRegFlatClass{}, \syncRegFullClass{} и т.\:д. Ключевое требование к классам индуктивных инвариантов над АТД~--- это возможность представлять бесконечные множества кортежей термов конечным образом, чтобы с ними мог работать конечный вычислитель. Кроме этого, от них требуется замкнутость и разрешимость некоторых операций, которые были подробно рассмотрены в этой главе. Конечные представления множеств термов с такими свойствами исследуются в других областях информатики и могут быть использованы для вывода инвариантов.

Одной из альтернативных формулировок задачи конечного представления множеств термов является задача представления эрбрановских моделей, которой занимается область автоматического построения моделей (automated model building)~\cite{caferra2013automated}. Основная задача этой области~--- автоматически построить модель формулы логики первого порядка, когда её опровержение не может быть найдено. По теореме Эрбрана, формула выполнима тогда и только тогда, когда у неё есть эрбрановская модель, поэтому достаточно строить только эрбрановские модели, которые в общем случае содержат в себе бесконечные множества термов. Для автоматизации построения таких моделей рассматривают различные конечные их представления~\cite{fermuller2007model,fermuller2005model,teucke2019expressivity,gramlich2002algorithmic}. В частности, в этих работах приведены эффективные алгоритмы для работы с моделями, представленными автоматами над деревьями и их расширениями. Качественный обзор вычислительных представлений эрбрановских моделей, их свойств, выразительной силы и эффективности необходимых для работы с ними процедур представлен в работах~\cite{matzinger1998computational, matzinger2000computational}. Хотя предложенные в данных работах представления могут быть использованы для представления инвариантов над АТД, создание алгоритмов вывода таких инвариантов остаётся трудоёмкой задачей, которая не затрагивалась в этих работах.

Задачу конечного представления множеств термов можно также сформулировать в контексте формальных языков деревьев как задачу построения расширений автоматов над деревьями, обладающих свойствами разрешимости и замкнутости базовых языковых операций, рассмотренных в этой главе. Языки деревьев систематически рассматриваются в контексте формальных языков~\cite{10.5555/267871}, в частности, существует множество работ, предлагающих внедрение различных видов синхронизации в автоматы над деревьями~\cite{chabin2007visibly, gouranton2001synchronized, limet2001weakly, chabin2006synchronized, jacquemard2009rigid, engelfriet2017multiple}. Однако с предлагаемыми в этой области представлениями есть несколько ограничений. С одной стороны, чаще всего предлагаются языки с эффективным (полиномиальным с низкой степенью полинома) алгоритмом парсинга (принадлежности кортежа термов языку), из-за чего предлагаемые языки имеют низкую выразительную силу. С другой стороны, часто предлагаются классы языков деревьев, не замкнутые относительно некоторых булевых операций, например, отрицания и пересечения, что делает задачу адаптации этих классов для вывода индуктивных инвариантов ещё более трудоёмкой.

Стоит отдельно упомянуть работы по расширению автоматов над деревьями SMT-ограничениями из других теорий до т.\:н. символьных автоматов над деревьями~\cite{VEANES2015418,10.1145/2933575.2933578}. Класс инвариантов, построенный на таких автоматах, позволит проверять выполнимость систем дизъюнктов Хорна над комбинацией АТД с другими SMT-теориями, как было замечено в работе~\cite{10.1007/978-3-031-13188-2_13}. Авторы этой работы начали адаптацию символьных автоматов к задаче проверке выполнимости систем дизъюнктов Хорна в рамках, реализовав учитель для этого класса инвариантов в рамках подхода \ice{}. Дальнейшее исследование класса инвариантов, построенного на символьных автоматах над деревьями, в рамках задачи автоматического вывода инвариантов представляется наиболее перспективным.

Итак, конечные представления множеств кортежей термов, представленные в работах из этих областей, могут стать основой для будущих классов индуктивных инвариантов над АТД. Поскольку многие из них построены как расширения классов, рассмотренных в данной работе, предложенные в данной работе методы вывода инвариантов могут быть также адаптированы, чтобы выводить инварианты в новых классах.

\section{Выводы}
Среди всех классов инвариантов программ, для которых существуют эффективные процедуры автоматического вывода инвариантов, наиболее выразительными являются классы \syncRegFullClass{} и \regelemclass{}. Они позволяют как выражать сложные рекурсивные отношения, так и синхронные отношения, и следовательно, они расширяют применимость автоматического вывода инвариантов на практике. Однако из-за высокой выразительной силы автоматическое построение инвариантов в этих классах может быть затруднено в виду роста сложности примитивных операций.
В следующей главе приведено сравнение эффективности существующих и предложенных методов вывода инвариантов для рассмотренных классов.
