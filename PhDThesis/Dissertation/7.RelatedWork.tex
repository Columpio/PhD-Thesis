\chapter{Сравнение и соотнесения}\label{ch:relatedWork}

Раздел~\cref{sec:relatedWork/hornSolvers} данной главы посвящен сравнению предложенных методов решения систем дизъюнктов Хорна с алгебраическими типами данных и существующих методов, реализованных в таких инструментах, как \spacer{}, \racer{}, \eldarica{}, \vericat{}, \hoice{} и \rchc{}. Данные инструменты были отобраны по следующему принципу: инструменты, поддерживающие системы дизъюнктов Хорна над алгебраическими типами данных, которые проверяют как выполнимость, так и не выполнимость этих систем. Так, например, не рассматривались инструменты, решающие родственную проблему автоматизации индукции для теорем с алгебраическими типами данных, такие как, например, \cvc{} в режиме индукции~\cite{reynolds2015induction} (см. предыдущий раздел), \textsc{AdtInd}~\cite{10.1007/978-3-030-30048-7_35} и пр., поскольку они не принимают на вход системы дизъюнктов Хорна. Также не рассматривались инструменты логического программирование (такие, как \textsc{Prolog}~\cite{ClocksinMellish03}), поскольку они позволяют проверять только невыполнимость систем дизъюнктов Хорна и ничего не говорят об их выполнимости.

В разделе~\cref{sec:relatedWork/modelBuilding} представлен обзор альтернативных рассмотренным способов представления бесконечных множеств термов, основанных на обобщениях автоматов над деревьями, которые могут послужить в качестве классов индуктивных инвариантов программ в будущем.

\section{Хорн-решатели с поддержкой АТД}\label{sec:relatedWork/hornSolvers}

\begin{table} [htbp]
    \centering
    \begin{threeparttable}% выравнивание подписи по границам таблицы
        \caption{Сравнение Хорн-решателей с поддержкой АТД}\label{tab:hornSolvers}%
        \begin{tabular}{| m{41mm} || x{29mm} | x{28mm} | x{27mm} | x{26mm} |}
            \hline
            \hline
Инструмент & Класс\quad\ \ \  инвариантов & Метод & Возвращает инвариант & Полностью автоматический\\\hline\hline
\spacer{} & \elemclass{} & \pdr{} & Да & Да\\
\racer{} & \catelemclass{} & \pdr{} & Нет & Нет\\
\eldarica{} & \sizeelemclass{} & \cegar{} & Да & Да\\
\vericat{} & -- & Трансф. & Нет & Да\\
\hoice{} & \elemclass{} & \ice{} & Да & Да\\
\rchc{}  & \syncRegFlatClass{} & \ice{} & Да & Да\\\hline
\ringenShort{\cvc} & \regclass{} & Трансф. + \fmf{} & Да & Да\\
\ringenShort{\vampire} & -- & Трансф. + \satur{} & Нет & Да\\
\ringenSyncShort{} & \syncRegFullClass{} & Трансф. + \fmf{} & Да & Да\\
\ringenCICIShort{\cvc} & \regelemclass{} & \ourCEGAR{} & Да & Да\\
\ringenCICIShort{\vampire} & -- & \ourCEGAR{} & Нет & Да\\
            \hline
            \hline
        \end{tabular}
    \end{threeparttable}
\end{table}

В таблице~\cref{tab:hornSolvers} представлены результаты сравнения работе Хорн-решателей~--- существующих (верхний блок) и предложенных в данной (нижний блок). Предложенные Хорн-решатели описаны в предыдущей главе~\ref{ch:evaluation}, реализуемые ими методы описаны в главах~\ref{ch:fmf},~\ref{ch:SyncReg} и~\ref{ch:cici} данной работы. В таблице, для краткости, название \theringen{} сокращено до \theringenShort{}, так, например, Хорн-решатель \ringenSync{} в таблице представлен как \ringenSyncShort{}. Под словом <<Трансф.>> имеется в виду, что инструмент построен на применении нетривиальных трансформаций к системе; аббревиатура <<FMF>> обозначает применение автоматического поиска конечных моделей (<<finite-model finding>>, см., например,~\cite{10.1007/978-3-319-40970-2_20,reynolds2013finite}); прочерк в столбце <<Класс инвариантов>> означает следующее: несмотря на то, что при выполнимости системы вывод инструмента неявно кодирует её индуктивный инвариант, не существует всюду останавливающейся процедуры, позволяющей этот вывод проверить. Остальные обозначения поясняются в подразделах, посвящённых соответствующим инструментам.

Большинство рассмотренных инструментов отличаются классами, в которых они ищут индуктивные инварианты. Сравнение самих классов инвариантов было приведено в главе~\cref{ch:comparison}. В контексте сопоставления инструментов сравнение их классов инвариантов важно по следующей причине: если инструмент выводит инварианты в некотором классе, то проблема невыразительности этого класса (невозможность выразить определённые типы отношений) превращается в проблему незавершаемости этого инструмента. Иными словами, поскольку ни один из существующих инструментов не проверяет, существует ли \emph{вообще} инвариант для данной системы дизъюнктов Хорна в его классе\footnote{С одной стороны, эта задача по сложности сравнима с самой задачей верификации, с другой же стороны до сих пор ей были посвящены лишь отдельные работы (см., например,~\cite{10.1145/3022187,10.1145/2837614.2837640})}, то в случае отсутствия такового инструмент не будет завершаться.

Далее приведено краткое сравнительное описание существующих инструментов.

\paragraph{Инструмент \spacer{}~\cite{komuravelli2016smt}} строит элементарные модели (класс \elemclass{}). Этот инструмент создан на основе классической разрешающей процедуры для АТД, а также процедуры интерполяции и устранения кванторов~\cite{bjorner2015playing}. Ядром инструмента является подход \spacer{}, который основан на технике, называемой \emph{достижимость, направляемая свойством} \foreignlanguage{english}{(property-directed reachability, \pdr{})}, которая равномерно распределяет время анализа между поиском контрпримеров и построением безопасного индуктивного инварианта, распространяя информацию о достижимости небезопасных свойств и частичные леммы о безопасности. Инструмент позволяет выводить инварианты в комбинации алгебраических и других типов данных, возвращает проверяемые сертификаты. Подход, используемый в инструменте, корректен и полон. Недостатком инструмента является то, что он выражает инварианты в языке ограничений, а потому часто не завершается на проблемах с АТД.

\paragraph{Инструмент \racer{}~\cite{10.1145/3498722}} является развитием инструмента \spacer{}, позволяя выводить инварианты в языке ограничений, расширенном катаморфизмами. Этот язык ограничений обозначен в таблице~\ref{tab:hornSolvers} как \catelemclass{}. \racer{} также наследует все достоинства подхода \spacer{}. Недостатком подхода является то, что он не полностью автоматический, поскольку требует вручную описывать катаморфизмы, что может быть затруднительно на практике, поскольку по заданной проблеме бывает сложно понять, какие катаморфизмы потребуются для её инварианта. Недостатком самого инструмента является то, что он не возвращает какие-либо проверяемые сертификаты с катаморфизмами.

\paragraph{Инструмент \eldarica{}~\cite{8603013}} строит модели с ограничениями размера термов, которые вычисляют общее количество вхождений конструкторов (класс \sizeelemclass{}). Это расширение весьма ограниченно увеличивает выразительность языка ограничений, поскольку введённая функция считает количество всех конструкторов одновременно, поэтому с её помощью невозможно выразить многие свойства, например, ограничение на высоту дерева. Инструмент \eldarica{} использует подход \cegar{} с абстракцией предикатов и встроенный SMT-решатель \princess{}~\cite{princess}, который предоставляет разрешающую процедуру, а также процедуру интерполяции для АТД с ограничениями на размер термов. Эти процедуры построены на сведении данной теории к комбинации теорий неинтерпретируемых функций и линейной арифметики~\cite{hojjat2017deciding}.

\paragraph{Инструмент \vericat{}~\cite{10.1093/logcom/exab090,pettorossi_proietti_2022,10.1007/978-3-030-51074-9_6,angelis_fioravanti_pettorossi_proietti_2018}} обрабатывает условия проверки над теориями линейной арифметики и АТД и полностью устраняет АТД из исходной системы дизъюнктов путём сворачивания (fold), разворачивания (unfold), введения новых дизъюнктов и других трансформаций. После работы инструмента получается система дизъюнктов Хорна без АТД, на которой может быть запущен любой эффективный Хорн-решатель, например, \spacer{} или \eldarica{}. Основным достоинством подхода является тот факт, что он рассчитан на работу с проблемами, где алгебраические типы данных комбинированы с другими теориями. Основные недостатки подхода заключаются в следующем: сам процесс трансформации может также не завершаться, кроме этого из-за трансформации невозможно восстановить инвариант исходной системы, т.\:е. инструмент не возвращает проверяемого сертификата.

\paragraph{Инструмент \hoice{}~\cite{10.1007/978-3-030-02768-1_8}} строит элементарные инварианты с помощью подхода, основанного на машинном обучении, \ice{}~\cite{10.1007/978-3-319-08867-9_5}. Его достоинством является возможность выводить инварианты в комбинации АТД с другими теориями, а также корректность и полнота, и, наконец, способность возвращать проверяемые сертификаты корректности. Его недостатком является то, что он выводит инварианты в невыразительном языке ограничений, а потому часто не завершается.

\paragraph{Инструмент \rchc{}~\cite{haude2020,losekoot_et_al:LIPIcs.FSCD.2023.7}} также использует подход \ice{}; \rchc{} основан на машинном обучении, однако выражает индуктивные инварианты программ над АТД при помощи \emph{автоматов над деревьями}~\cite{tata}. Но из-за сложностей с выражением кортежей термов автоматами, описанных в разделе~\ref{sec:comparison/undef-in-sync}, подход часто оказывается неприменим для простейших примеров, где существуют классические символьные инварианты. 

\paragraph{Выводы.} Подводя итоги сравнения вышеозначенных инструментов и методов, можно сказать следующее. По сравнении с методом инструмента \rchc{} предложенные в данной диссертационной работе подходы являются альтернативными способами вывода регулярных инвариантов и их надклассов. Поэтому они могут быть совмещены с подходом инструмента \rchc{}, чтобы быстрее сходиться к индуктивному инварианту системы, если он существует. В сравнении с методами остальных существующих инструментов, предложенные подходы позволяют выводить инварианты в независимых классах регулярных инвариантов. Поэтому применение предложенных методов совместно с существующими позволит решать больше различных типов задач.

\section{Конечные представления множеств термов}\label{sec:relatedWork/modelBuilding}
В данной работе были рассмотрены и предложены различные классы инвариантов для систем дизъюнктов Хорна над АТД, такие, как \elemclass{}, \regclass{}, \syncRegFlatClass{}, \syncRegFullClass{} и т.\:д. Ключевое требование к классам индуктивных инвариантов над АТД~--- это возможность представлять бесконечные множества кортежей термов конечным образом, чтобы с ними мог работать конечный вычислитель. Кроме этого, от них требуется замкнутость и разрешимость некоторых операций, которые были подробно рассмотрены в главе~\ref{ch:comparison}. Конечные представления множеств термов с такими свойствами исследуются в других областях информатики и могут быть использованы для вывода инвариантов.

Одной из альтернативных формулировок задачи конечного представления множеств термов является задача представления эрбрановских моделей, которой занимается область автоматического построения моделей (automated model building)~\cite{caferra2013automated}. Основная задача этой области~--- автоматически построить модель формулы логики первого порядка, когда её опровержение не может быть найдено. По теореме Эрбрана, формула выполнима тогда и только тогда, когда у неё есть эрбрановская модель, поэтому достаточно строить только эрбрановские модели, которые в общем случае содержат в себе бесконечные множества термов. Для автоматизации построения таких моделей рассматривают различные конечные их представления~\cite{fermuller2007model,fermuller2005model,teucke2019expressivity,gramlich2002algorithmic}. В частности, в этих работах приведены эффективные алгоритмы для работы с моделями, представленными автоматами над деревьями и их расширениями. Качественный обзор вычислительных представлений эрбрановских моделей, их свойств, выразительной силы и эффективности необходимых для работы с ними процедур представлен в работах~\cite{matzinger1998computational, matzinger2000computational}. Хотя предложенные в данных работах представления могут быть использованы для представления инвариантов над АТД, создание алгоритмов вывода таких инвариантов остаётся трудоёмкой задачей, которая не затрагивалась в этих работах.

Задачу конечного представления множеств термов можно также сформулировать в контексте формальных языков деревьев как задачу построения расширений автоматов над деревьями, обладающих свойствами разрешимости и замкнутости базовых языковых операций, рассмотренных в главе~\ref{ch:comparison}. Языки деревьев систематически рассматриваются в контексте формальных языков~\cite{10.5555/267871}, в частности, существует множество работ, предлагающих внедрение различных видов синхронизации в автоматы над деревьями~\cite{chabin2007visibly, gouranton2001synchronized, limet2001weakly, chabin2006synchronized, jacquemard2009rigid, engelfriet2017multiple}. Однако с предлагаемыми в этой области представлениями есть несколько ограничений. С одной стороны, чаще всего предлагаются языки с эффективным (полиномиальным с низкой степенью полинома) алгоритмом парсинга (принадлежности кортежа термов языку), из-за чего предлагаемые языки имеют низкую выразительную силу. С другой стороны, часто предлагаются классы языков деревьев, не замкнутые относительно некоторых булевых операций, например, отрицания и пересечения, что делает задачу адаптации этих классов для вывода индуктивных инвариантов ещё более трудоёмкой.

Стоит отдельно упомянуть работы по расширению автоматов над деревьями SMT-ограничениями из других теорий до т.\:н. символьных автоматов над деревьями~\cite{VEANES2015418,10.1145/2933575.2933578}. Класс инвариантов, построенный на таких автоматах, позволит проверять выполнимость систем дизъюнктов Хорна над комбинацией АТД с другими SMT-теориями, как было замечено в работе~\cite{10.1007/978-3-031-13188-2_13}. Авторы этой работы начали адаптацию символьных автоматов к задаче проверке выполнимости систем дизъюнктов Хорна в рамках, реализовав учитель для этого класса инвариантов в рамках подхода \ice{}. Дальнейшее исследование класса инвариантов, построенного на символьных автоматах над деревьями, в рамках задачи автоматического вывода инвариантов представляется наиболее перспективным.

Итак, конечные представления множеств кортежей термов, представленные в работах из этих областей, могут стать основой для будущих классов индуктивных инвариантов над АТД. Поскольку многие из них построены как расширения классов, рассмотренных в данной работе, предложенные в данной работе методы вывода инвариантов могут быть также адаптированы, чтобы выводить инварианты в новых классах.
