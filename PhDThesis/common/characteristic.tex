{\actuality}
Программные системы охватывают всё больше сфер человеческой деятельности, и всё острее стоит вопрос об их корректности.
Область формальных методов традиционно занимается вопросами качества программ. С 90-х годов XX века в этой области начинается новая страница~--- появились бинарные диаграммы решений, а затем символьная проверка моделей на основе эффективных SAT-решателей, что позволило верифицировать системы с \(10^{120}\) возможными состояниями~\cite{10.1007/3-540-61474-5_93}. Благодаря SAT-революции всё меньше статических анализаторов создаётся <<с нуля>>, всё чаще они  надстраиваются над стеком верификации: SAT-решатели для логики высказываний, построенные на их основе SMT-решатели для теорий логики первого порядка, и далее~--- Хорн-решатели для вывода индуктивных инвариантов.

Новые подходы к статическому анализу дают индустрии много плодов.
Так, например, в 2008 году около трети всех детектируемых ошибок при разработке Windows~7 нашёл инструмент SAGE~\cite{10.1145/2090147.2094081}, основанный на символьном исполнении и активно использующий SMT-решатель для проверки достижимости ветвей исполнения программ.

 В формальных методах большое значение имеют типы данных, так как для них требуются подходящие формализации, чтобы учитывать их при верификации программ. Однако большинство исследований здесь направлено на поддержку <<классических>> типов данных, таких как целые числа и массивы. Менее исследованными оказываются новые, набирающие популярность, типы данных, например, \emph{алгебраические типы данных (АТД)}\footnote{В зависимости от подхода их также называют \emph{абстрактными типами данных}, \emph{индуктивными типами данных} и \emph{рекурсивными типами данных}.}.
Последние строятся рекурсивно, при помощи объединения и декартового перемножения типов. Используя АТД, можно описывать  односвязные списки,  бинарные деревья и другие сложные структуры данных.  АТД активно используются в функциональных языках, таких как \haskell{} и \ocaml{},  являясь альтернативой перечислениям и объединениям в языках \clanguage{} и \cplusplus{}. Алгебраические типы данных всё чаще включают в современные языки программирования, используемые в индустрии, например, в языки \rust{} и \scala{}, а также в языки самовыполняющихся контрактов, например, \solidity{}~\cite{8327565}. Так, например, Twitter использует язык \scala{} для большинства своих серверных приложений~\cite{10.1145/1900160.1900170}, Dropbox~--- язык \rust{} для управления потоками данных~\cite{dropboxRust}, и в обоих случая активно используются алгебраические типы данных.

Таким образом становится насущной задача обеспечения корректности программ, использующих  АТД.
Эта задача может быть формализована, а её решение~--- частично автоматизировано в рамках дедуктивной верификации на основе логики Флойда-Хоара~\cite{Floyd1993,10.1145/363235.363259} или уточняющих типов (refinement types)~\cite{713327}, как, например, в системах \flux{}~\cite{https://doi.org/10.48550/arxiv.2207.04034} для языка \rust{} и \leon{}~\cite{10.1007/978-3-642-23702-7_23} для языка \scala{}.
Однако такие подходы  требуют от пользователя предоставления \emph{индуктивных инвариантов} для доказательства корректности программы, формулировка которых на практике является крайне трудоёмкой задачей. Системы верификации, основанные на самостоятельных языках программирования и поддерживающие АТД, такие как \dafny{}~\cite{10.1007/978-3-642-17511-4_20}, \whyThree{}~\cite{10.1007/978-3-642-37036-6_8}, \viper{}~\cite{10.1007/978-3-662-49122-5_2}, \fstar{}~\cite{10.1145/2914770.2837655}, сталкиваются с той же проблемой.
Также следует отметить, что алгебраические типы данных лежат в основе многочисленных интерактивных систем проверки доказательств (interactive theorem prover, ITP), таких как \coq{}~\cite{barras1999coq}, \idris{}~\cite{brady_2013}, \agda{}~\cite{10.1145/3341691}, \lean{}~\cite{10.1007/978-3-030-79876-5_37}.
Методы автоматизации индукции в таких системах, как правило, ограничены синтаксическим перебором, поэтому в процессе доказательства пользователь вынужден осуществлять трудоёмкую деятельность  по формулировке точной индукционной гипотезы, что тождественно проблеме вывода индуктивных инвариантов.

Таким образом эти задачи сводятся к задаче автоматического вывода индуктивных инвариантов программ с алгебраическими типами данных. В общем виде она может быть сформулирована при помощи систем \emph{дизъюнктов Хорна с ограничениями} (constrained Horn clauses, CHCs)~--- логических формул специального вида, которые позволяют точно моделировать работу программы~\cite{MAKOWSKY1987266}.

Поскольку задача автоматического вывода индуктивных инвариантов сводится к задаче поиска модели для системы дизъюнктов Хорна с ограничениями, инструменты автоматического поиска таких моделей (т. н. <<Хорн-решатели>>) могут быть применены в различных контекстах верификации программ~\cite{10.1145/2254064.2254112,Bjorner2015}.
Так, например, инструмент \rustHorn{}~\cite{10.1145/3462205} использует Хорн-решатели для верификации \rust{}-программ, а инструмент \solCMC{}~\cite{10.1007/978-3-031-13185-1_16} применяется для верификации самовыполняющихся контрактов на языке \solidity{}.

Существуют эффективные Хорн-решатели, поддерживающие АТД, такие как \spacer{}~\cite{komuravelli2016smt} и его приемник \racer{}~\cite{10.1145/3498722}, а также \eldarica{}~\cite{8603013}, \hoice{}~\cite{10.1007/978-3-030-02768-1_8}, \rchc{}~\cite{haude2020}, \vericat{}~\cite{de_angelis_proietti_fioravanti_pettorossi_2022}.
Среди Хорн-решателей проводятся ежегодные международные соревнования \chccomp{}~\cite{De_Angelis_2022}, где отдельная секция посвящена решению систем дизъюнктов Хорна с алгебраическими типами данных.

Решение выполнимой системы дизъюнктов Хорна классически представляется в виде т.н. \emph{символьной модели} (symbolic model)~\cite{Bjorner2015}, т.е. модели, выраженной при помощи формул логики первого порядка в языке ограничений системы дизъюнктов.
Поэтому класс всех индуктивных инвариантов, выразимых с помощью языка ограничений, будем называем \emph{классическими символьными инвариантами}.
Так, например, все Хорн-решатели, участвовавшие в соревнованиях \chccomp{} за последние два года, строят классические символьные инварианты.

Проблема символьных инвариантов в контексте алгебраических типов данных заключается в том, что язык ограничений АТД \emph{не позволяет выразить индуктивные инварианты большинства программ, востребованных на практике}.
А если у безопасной программы нет индуктивных инвариантов, выразимых на языке ограничений, ни один алгоритм вывода индуктивных инвариантов на этом языке не сможет построить для неё индуктивный инвариант. 
Это приводит к тому, что \emph{Хорн-решатели, строящие классические символьные инварианты, не завершаются на большинстве систем с алгебраическими типами данных}.

Термы алгебраических типов имеют \emph{рекурсивную структуру}. Например, бинарное дерево~--- это либо лист, либо вершина с двумя потомками, которые тоже являются бинарными деревьями.
Поэтому основная причина, по которой язык ограничений АТД не позволяет выразить индуктивные инварианты многих программ, состоит в том, что он не позволяет выражать \emph{рекурсивные отношения} над термами алгебраических типов.

{\progress} Проблема невыразимости языка ограничений хорошо известна в научном сообществе. Предпринималось несколько попыток решить эту проблему.

Так в 2018 году Ф.~Рюммер (P.~Ruemmer, Швеция) в рамках Хорн-решателя \eldarica{}~\cite{8603013} предложил выводить индуктивные инварианты в языке ограничений, расширенном функцией размера, подсчитывающей число конструкторов в терме. Однако проблемой этого  подхода является то, что любое расширение языка ограничений требует существенной переработки всей процедуры вывода индуктивных инвариантов.
Также в 2022 году в рамках Хорн-решателя \racer{} (H.~Govind, A.~Gurfinkel, США)~\cite{10.1145/3498722} было предложено расширить язык ограничений катаморфизмами~--- рекурсивными функциями некоторого простого вида. Однако в этом случае от пользователя требуется заранее задавать катаморфизмы, которые будут использованы для построения индуктивного инварианта, поэтому этот подход нельзя назвать вполне автоматическим.
% Общей проблемой этих двух подходов является то, что любое расширение языка ограничений требует существенной переработки всей процедуры вывода индуктивных инвариантов.

C 2018 года ведётся отдельная линия исследований (E.~De~Angelis, F.~Fioravant, A.~Pettorossi, Италия)~\cite{10.1093/logcom/exab090,pettorossi_proietti_2022,10.1007/978-3-030-51074-9_6,angelis_fioravanti_pettorossi_proietti_2018}, посвящённая  методам устранения алгебраических типов из системы дизъюнктов путём сведения её к системе над более простой теорией, например, над линейной арифметикой. Такой подход реализован в  инструменте \vericat{}~\cite{de_angelis_proietti_fioravanti_pettorossi_2022}. Ограничением подобных подходов является невозможность восстановления индуктивного инварианта исходной системы из индуктивного инварианта более простой системы.

В 2020 году в рамках инструмента \rchc{} (T.~Haudebourg, Франция)~\cite{haude2020} было предложено выражать индуктивные инварианты программ над АТД при помощи \emph{автоматов над деревьями}~\cite{tata}. Однако из-за сложностей с представлением кортежей термов автоматами, предложенный класс инвариантов не включает в себя классические символьные инварианты, поэтому подход часто оказывается неприменимым для простейших программ, где такие инварианты легко находятся классическими методами.

{\aim} данной работы является предложение новых классов индуктивных инвариантов для программ с алгебраическими типами данных и создание для них методов автоматического вывода.
Для  реализации этой цели были сформулированы следующие {\tasks}.
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Предложить новые классы индуктивных инвариантов программ с алгебраическими типами данных, позволяющие выражать рекурсивные отношения и включающие классические символьные инварианты.
  \item Создать методы автоматического вывода индуктивных инвариантов в новых классах.
  \item Выполнить пилотную программную реализацию предложенных методов.
  \item Провести экспериментальное сопоставление реализованного инструмента с существующими на представительном  тестовом наборе.
\end{enumerate}

{\methods}
Методология исследования заключается в проектировании применимых на практике  классов индуктивных инвариантов совместно с разработкой  соответствующих алгоритмов, активно используя существующие результаты этой области.
В работе используется  логика первого порядка, а также базовые концепции теории автоматов и формальных языков, включая автоматы над деревьями, синхронные автоматы, язык автомата, лемму о <<накачке>>.
Пилотная программная реализация теоретических результатов выполнена на языке \fsharp{}, а также частично на языке \cplusplus{} в рамках кодовой базы Хорн-решателя \racer{} (входит в SMT-решатель \zprover{}, Microsoft Research).

{\defpositions}
% В папке Documents можно ознакомиться с решением совета из Томского~ГУ (в~файле \verb+Def_positions.pdf+), где обоснованно даются рекомендации по~формулировкам защищаемых положений.
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Предложен эффективный метод автоматического вывода индуктивных инвариантов, основанных на автоматах над деревьями; при этом данные инварианты позволяют выражать рекурсивные отношения в большем количестве реальных программ; метод базируется на поиске конечных моделей.
  \item Предложен  метод автоматического вывода индуктивных инвариантов, основанный на трансформации программы и поиске конечных моделей, в сложном для автоматического вывода инвариантов классе, основанном на синхронных автоматах над деревьями; этот класс инвариантов позволяет выражать рекурсивные отношения и обобщает классические символьные инварианты.
  \item Предложен класс индуктивных инвариантов, основанный на булевой комбинации классических инвариантов и автоматов над деревьями, который, с одной стороны, позволяет выражать рекурсивные отношения в реальных программах, а, с другой стороны, позволяет эффективно выводить индуктивные инварианты; также предложен эффективный метод совместного вывода индуктивных инвариантов в этом классе посредством вывода инвариантов в подклассах.
  \item Проведено теоретическое сравнение существующих и предложенных в рамках диссертации классов индуктивных инвариантов; в том числе сформулированы и доказаны леммы о <<накачке>> для языка ограничений и для языка ограничений расширенного функцией размера терма.
  \item Выполнена пилотная программная реализация предложенных методов на языке \fsharp{} в рамках инструмента \theringen{}; инструмент сопоставлен с существующими методами на общепринятом тестовом наборе задач верификации функциональных программ <<Tons of Inductive Problems>>; реализация наилучшего из предложенных методов смогла за отведённое время решить в 3.74 раза больше задач, чем наилучший из существующих инструментов.
\end{enumerate}

{\novelty{} полученных результатов состоит в следующем.}
\begin{enumerate}[beginpenalty=10000] % https://tex.stackexchange.com/a/476052/104425
  \item Впервые предложен класс индуктивных инвариантов, основанный на булевой комбинации классов классических и инвариантов, основанных на автоматах над деревьями.
  \item Впервые предложен алгоритм вывода индуктивных инвариантов для программ с алгебраическими типами данных, основанный на поиске конечных моделей.
  \item Предложен новый алгоритм совместного вывода индуктивных инвариантов в комбинации классов инвариантов на базе имеющихся методов вывода инвариантов для отдельных классов.
  \item Впервые введены и доказаны леммы о <<накачке>> для языков первого порядка в сигнатуре теории алгебраических типов данных.
\end{enumerate}

{\influenceTh}
Диссертационное исследование предлагает новые подходы к выводу индуктивных инвариантов программ. Поскольку эти подходы ортогональны существующим, они могут быть перенесены на программы над другими теориями, например, над теорией массивов, а также могут усилить уже существующие подходы к выводу индуктивных инвариантов. Также важным теоретическим вкладом является адаптация лемм о <<накачке>> к языкам первого порядка: эти леммы открывают путь к фундаментальному исследованию проблемы невыразимости индуктивных инвариантов в языках первого порядка и проектированию новых классов индуктивных инвариантов программ.

{\influencePr}
Предложенные методы могут быть применены при создании  статических анализаторов для языков с алгебраическими типами данных: поскольку индуктивные инварианты аппроксимируют циклы и функции, они позволяют анализатору корректно <<срезать>> целые классы недостижимых состояний программы и не <<увязать>> в циклах и рекурсии.
Например, предложенные методы могут быть полезны в разработке верификаторов и генераторов тестовых покрытий для таких языков, как \rust{}, \scala{}, \solidity{}, \haskell{} и \ocaml{}.
Поскольку для предложенных методов была выполнена пилотная программная реализация, полученный Хорн-решатель также может быть использован в качестве <<ядра>> статического анализатора, например, для языка \rust{} при помощи фреймворка \rustHorn{}.

{\reliability} полученных результатов обеспечивается формальными доказательствами, а также компьютерными экспериментами на публичных общепринятых тестовых наборах.
Полученные в диссертации результаты согласуются с результатами других авторов в области вывода индуктивных инвариантов.

{\probation}
Основные результаты работы докладывались на следующих научных конференциях и семинарах:
международном семинаре HCVS 2021 (28 марта 2021, Люксембург),
семинаре компании Huawei (18-19 ноября 2021, Санкт-Петербург),
ежегодном внутреннем семинаре JetBrains Research (18 декабря 2021, Санкт-Петербург),
конференции PLDI 2021 (23-25 июня 2021, Канада),
внутреннем семинаре Венского технического университета (3 июня 2022, Австрия),
конференции LPAR 2023 (4-9 июня 2023, Колумбия).

Разработанный инструмент в 2021 и 2022 годах занял, соответственно, 2 и 1 место на международных соревнованиях \chccomp{} (секция по  выводу индуктивных инвариантов для программ с алгебраическими типами данных).


\ifnumequal{\value{bibliosel}}{0}
{%%% Встроенная реализация с загрузкой файла через движок bibtex8. (При желании, внутри можно использовать обычные ссылки, наподобие `\cite{vakbib1,vakbib2}`).
    {\publications} Основные результаты по теме диссертации изложены
    в~XX~печатных изданиях,
    X из которых изданы в журналах, рекомендованных ВАК,
    X "--- в тезисах докладов.
}%
{%%% Реализация пакетом biblatex через движок biber
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=1.
        % Процитированные здесь работы:
        %  * подсчитываются, для автоматического составления фразы "Основные результаты ..."
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthor` или `\insertbiblioauthorgrouped`
        %  * нумеруются там в зависимости от порядка команд `\printbibliography` в этом разделе.
        %  * при использовании `\insertbiblioauthorgrouped`, порядок команд `\printbibliography` в нём должен быть тем же (см. biblio/biblatex.tex)
        %
        % Невидимый библиографический список для подсчёта количества публикаций:
        \printbibliography[heading=nobibheading, section=1, env=countauthorvak,          keyword=biblioauthorvak]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorwos,          keyword=biblioauthorwos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopus,       keyword=biblioauthorscopus]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorconf,         keyword=biblioauthorconf]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorother,        keyword=biblioauthorother]%
        \printbibliography[heading=nobibheading, section=1, env=countregistered,         keyword=biblioregistered]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorpatent,       keyword=biblioauthorpatent]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorprogram,      keyword=biblioauthorprogram]%
        \printbibliography[heading=nobibheading, section=1, env=countauthor,             keyword=biblioauthor]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorvakscopuswos, filter=vakscopuswos]%
        \printbibliography[heading=nobibheading, section=1, env=countauthorscopuswos,    filter=scopuswos]%
        %
        \nocite{*}%
        %
        {\publications} Основные результаты по теме диссертации изложены в~\arabic{citeauthor}~печатных изданиях,
        \arabic{citeauthorvak} из которых изданы в журналах, рекомендованных ВАК\sloppy%
        \ifnum \value{citeauthorscopuswos}>0%
            , \arabic{citeauthorscopuswos} "--- в~периодических научных журналах, индексируемых Web of~Science и Scopus, одна из которых опубликована в тезисах конференции PLDI, имеющей ранг A*, и одна опубликована в тезисах конференции LPAR, имеющей ранг A\sloppy%
        \fi%
        \ifnum \value{citeauthorconf}>0%
            , \arabic{citeauthorconf} "--- в~тезисах докладов.
        \else%
            .
        \fi%
        \ifnum \value{citeregistered}=1%
            \ifnum \value{citeauthorpatent}=1%
                Зарегистрирован \arabic{citeauthorpatent} патент.
            \fi%
            \ifnum \value{citeauthorprogram}=1%
                Зарегистрирована \arabic{citeauthorprogram} программа для ЭВМ.
            \fi%
        \fi%
        \ifnum \value{citeregistered}>1%
            Зарегистрированы\ %
            \ifnum \value{citeauthorpatent}>0%
            \formbytotal{citeauthorpatent}{патент}{}{а}{}\sloppy%
            \ifnum \value{citeauthorprogram}=0 . \else \ и~\fi%
            \fi%
            \ifnum \value{citeauthorprogram}>0%
            \formbytotal{citeauthorprogram}{программ}{а}{ы}{} для ЭВМ.
            \fi%
        \fi%
        % К публикациям, в которых излагаются основные научные результаты диссертации на соискание учёной
        % степени, в рецензируемых изданиях приравниваются патенты на изобретения, патенты (свидетельства) на
        % полезную модель, патенты на промышленный образец, патенты на селекционные достижения, свидетельства
        % на программу для электронных вычислительных машин, базу данных, топологию интегральных микросхем,
        % зарегистрированные в установленном порядке.(в ред. Постановления Правительства РФ от 21.04.2016 N 335)
    \end{refsection}%
    \begin{refsection}[bl-author, bl-registered]
        % Это refsection=2.
        % Процитированные здесь работы:
        %  * попадают в авторскую библиографию, при usefootcite==0 и стиле `\insertbiblioauthorimportant`.
        %  * ни на что не влияют в противном случае
        % \nocite{vakbib2}%vak
        % \nocite{patbib1}%patent
        % \nocite{progbib1}%program
        % \nocite{bib1}%other
        % \nocite{confbib1}%conf
    \end{refsection}%
        %
        % Всё, что вне этих двух refsection, это refsection=0,
        %  * для диссертации - это нормальные ссылки, попадающие в обычную библиографию
        %  * для автореферата:
        %     * при usefootcite==0, ссылка корректно сработает только для источника из `external.bib`. Для своих работ~--- напечатает "[0]" (и даже Warning не вылезет).
        %     * при usefootcite==1, ссылка сработает нормально. В авторской библиографии будут только процитированные в refsection=0 работы.
}

% При использовании пакета \verb!biblatex! будут подсчитаны все работы, добавленные
% в файл \verb!biblio/author.bib!. Для правильного подсчёта работ в~различных
% системах цитирования требуется использовать поля:
% \begin{itemize}
%         \item \texttt{authorvak} если публикация индексирована ВАК,
%         \item \texttt{authorscopus} если публикация индексирована Scopus,
%         \item \texttt{authorwos} если публикация индексирована Web of Science,
%         \item \texttt{authorconf} для докладов конференций,
%         \item \texttt{authorpatent} для патентов,
%         \item \texttt{authorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{authorother} для других публикаций.
% \end{itemize}
% Для подсчёта используются счётчики:
% \begin{itemize}
%         \item \texttt{citeauthorvak} для работ, индексируемых ВАК,
%         \item \texttt{citeauthorscopus} для работ, индексируемых Scopus,
%         \item \texttt{citeauthorwos} для работ, индексируемых Web of Science,
%         \item \texttt{citeauthorvakscopuswos} для работ, индексируемых одной из трёх баз,
%         \item \texttt{citeauthorscopuswos} для работ, индексируемых Scopus или Web of~Science,
%         \item \texttt{citeauthorconf} для докладов на конференциях,
%         \item \texttt{citeauthorother} для остальных работ,
%         \item \texttt{citeauthorpatent} для патентов,
%         \item \texttt{citeauthorprogram} для зарегистрированных программ для ЭВМ,
%         \item \texttt{citeauthor} для суммарного количества работ.
% \end{itemize}
% Счётчик \texttt{citeexternal} используется для подсчёта процитированных публикаций;
% \texttt{citeregistered} "--- для подсчёта суммарного количества патентов и программ для ЭВМ.

% Для добавления в список публикаций автора работ, которые не были процитированы в
% автореферате, требуется их~перечислить с использованием команды \verb!\nocite! в
% \verb!Synopsis/content.tex!.

{\contribution} автора в совместных публикациях распределён следующим образом.
В статье~\cite{костюков2019автоматическое} автор выполнил  реализацию сведения поиска индуктивных инвариантов функций над сложными структурами данных к решению систем дизъюнктов Хорна, а также спроектировал  эксперименты с различными существующими Хорн-решателями; соавторы предложили саму идею и проработали её теоретические аспекты.
В работах~\cite{10.1145/3453483.3454055} автор провёл теоретическое сопоставление классов индуктивных инвариантов, предложил и доказал леммы о <<накачке>> для языков первого порядка над АТД, реализовал предлагаемый подход, поставил эксперименты; соавторы участвовали в обсуждении основных идей статьи, выполнили обзор существующих решений.
В статье~\cite{LPAR2023:Collaborative_Inference_of_Combined} автор предложил и формально обосновал коллаборационный подход к выводу инвариантов, реализовал прототип и поставил эксперименты; соавторы участвовали в обсуждении презентации идей статьи и выполнили обзор существующих решений.
В статье~\cite{мисонижник2022генерация} вклад автора заключается в формальном описании теории вычисления предусловий программ со сложными структурами данных; соавторы участвовали в обсуждении основных идей и реализовали подход.
